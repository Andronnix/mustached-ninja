<!DOCTYPE html>
<HTML>
  <HEAD>
    <style type="text/css">
      #gameCanvas {
        border: 1px solid black;
        position: absolute;
        top: 10px;
        left: 10px;
      }
      #instructions{
        position: absolute;
        top: 10px;
        left: 700px;
      }
      #instructions li{
        list-style-type: square;
      }
    </style>
  </HEAD>
  <BODY id="body" onload="load();">  
    <script src="lib\\easeljs-0.6.0.min.js"></script>
    <script src="lib\\preloadjs-0.3.0.min.js"></script>
    <script src="lib\\TS_vector2.js"></script>
    <script src="lib\\loadScreen.js"></script>
    <script src="lib\\soundjs-0.4.0.min.js"></script>
    


    <script>
      var WIDTH = 640, HEIGHT = 640;
      
      //usefull keycodes
      var KEYCODE_ENTER = 13;
      var KEYCODE_SPACE = 32;
      var KEYCODE_UP = 38, KEYCODE_LEFT = 37, KEYCODE_RIGHT = 39, KEYCODE_DOWN = 40; 
      var KEYCODE_W = 87, KEYCODE_A = 65, KEYCODE_D = 68, KEYCODE_S = 83;
      var KEYCODE_Q = 81, KEYCODE_E = 69;
      var KEYCODE_1 = 49, KEYCODE_2 = 50, KEYCODE_3 = 51;
      var KEYCODE_P = 80, KEYCODE_ESC = 27;   
      var KEYCODE_M = 77;   

      var LOAD_PARTS = 25;
      
      var DEBUG_FIELD;
      var DEBUG_SHAPE; 
      var DEBUG = false; 
      
      var paused = false;
      var muted = false;

      var lfHeld;       //is the user holding a turn left command
      var rtHeld;       //is the user holding a turn right command
      var fwdHeld;      //is the user holding a forward command
      var bwdHeld;      //is the user holding a backward command
      var shootHeld;    //is the user holding a shoot command
      var pauseHeld;    //is the user holding a pause command


      var body = document.getElementById("body");
      var stage;
      var player;
      var resources = [];

      var pause;
      
      var gMap;

      document.onkeydown = handleKeyDown;
      document.onkeyup = handleKeyUp;

      //запрос, передаем URI, контекст выполнения callback функции, сам callback, необязательный параметр асинхронного запроса, по умолчанию true
      function xhrGet(reqUri, context, callback, async) {
        async = async || true;
        var xhr = new XMLHttpRequest();
        xhr.open("GET", reqUri, async);
        xhr.onreadystatechange = function(){
          if(xhr.readyState == 4){
            callback.call(context, xhr);
          }
        }
          xhr.send();
      }

      //Функция записывает расстояние между прямоугольниками в dist, если оно меньше, чем текущее
      function getDistance(r0, r1, dist){
        var t = 0;
        if((r0.y2 > r1.y1) && (r1.y2 > r0.y1)){
          if(r1.x2 < r0.x1){
            t = r0.x1 - r1.x2;
            dist.left = (t < dist.left)? t : dist.left;
          }else{
            if(r0.x2 < r1.x1){
              t = r1.x1 - r0.x2;
              dist.right = (t < dist.right)? t : dist.right;
            }else{
              //Позволяем вылезти туда, куда короче
              if(r0.x2 - r1.x1 > r1.x2 - r0.x1)
                dist.left = 0;
              else{
                if(r0.x2 - r1.x1 < r1.x2 - r0.x1){
                  dist.right = 0;
                }
              }
            }
          }
          return;
        }

        if((r0.x2 > r1.x1) && (r1.x2 > r0.x1)){
          if(r1.y2 < r0.y1){
            t = r0.y1 - r1.y2;
            dist.up = (t < dist.up)? t : dist.up;
          }else{  
            if(r0.y2 < r1.y1){
              t = r1.y1 - r0.y2;
              dist.down = (t < dist.down)? t : dist.down;
            }else{
              //Позволяем вылезти туда, куда короче
              if(r0.y2 - r1.y1 > r1.y2 - r0.y1){
                dist.up = 0; //нельзя вверх
              }else if(r0.y2 - r1.y1 < r1.y2 - r0.y1){
                dist.down = 0; // нельзя вниз
              }
              
            }
          }
        }
      }
      //Возвращает расстояние до ближайших препятствий сверху, снизу, справа и слева
      function minDistance(r){
        var EPS = 1e-4;
        var obst = gMap.obstacles; 
        var zomb = gMap.zombies;   
        var r0 = {x1: r.x, y1: r.y, x2: r.x + r.w, y2: r.y + r.h};
        var r1 = null;
        var i = 0;
        var dist = {up:5*HEIGHT, down:5*HEIGHT, left:5*WIDTH, right:5*WIDTH};

        var ol = obst.length;
        for(i = ol - 1; i >= 0; i--){
          r1 = {x1: obst[i].x, y1: obst[i].y, x2: obst[i].x + obst[i].width, y2: obst[i].y + obst[i].height};
          getDistance(r0, r1, dist);          
        }

        var zl = zomb.length;

        for(i = zl - 1; i >= 0; i--){          
          r1 = {x1: zomb[i].animation.x - zomb[i].hitRadius, y1: zomb[i].animation.y - zomb[i].hitRadius,
                x2: zomb[i].animation.x + zomb[i].hitRadius, y2: zomb[i].animation.y + zomb[i].hitRadius};

          if( Math.abs(r1.x1 - r0.x1) < EPS && Math.abs(r1.x2 - r0.x2) < EPS && 
              Math.abs(r1.y1 - r0.y1) < EPS && Math.abs(r1.y2 - r0.y2) < EPS ){
            
            continue;//the same object
        }

          getDistance(r0, r1, dist);
        }    

        return dist;
      }

      function TextAnimation(owner, text, color, timer){
        this.timer = timer || 400;//animation ticks
        this.owner = owner;
        this.text = null;
        var self = this;
        this.animator = function(event){
          this.timer -= event.delta;
          if(this.timer < 0){

            stage.removeChild(this.text);
            var e = this.eL;
            createjs.Ticker.removeEventListener("tick", e);
            var tA = this.owner.textAnimation;
            for(var i = 0; i < tA.length; i++)
              if(tA[i] == this) tA.splice(i, 1);
            return;
          }
          this.text.y -= 1;
          this.text.alpha -= 0.009;
        }
        this.load = function(txt, color){
          this.text = new createjs.Text(txt, "bold 14px Arial", color);
          this.text.x = this.owner.animation.x;
          this.text.y = this.owner.animation.y - this.owner.hitRadius;
          this.eL = createjs.Ticker.addEventListener("tick", function(evt){self.animator(evt);});
          this.owner.textAnimation.push(this);
          stage.addChild(this.text);
        }
        this.move = function(dx,dy){
          this.text.x += dx;
          this.text.y += dy;
        }
        this.load(text, color);
      }

      //Класс зомби
      function Zombie(x, y){
        x = x || 0;
        y = y || 0;
        this.speed = 1.5;
        this.healthPoints = 0;
        this.maxHealthPoints = 0;

        this.attackTicker = 0;        
        this.attackDelay = 0;

        this.animation = null;
        this.textAnimation = [];


        this.hitRadius = 0;
        this.hitPoints = [];
        for(var i = 0; i<2; i++)this.hitPoints[i] = {x:0, y:0};
        this.hitBox = null;
        this.damage = 0;

        //небезопасный телепорт
        this.moveTo = function(x, y){
          var x0 = this.animation.x;
          var y0 = this.animation.y;
          this.animation.x = x;
          this.animation.y = y;
          if(this.textAnimation != null){
            var dx = x - x0, dy = y - y0;
            var tA = this.textAnimation;
            for(var i = 0; i < tA.length; i++)
              tA[i].move(dx, dy);
          }

          if(DEBUG){
            this.hitBox.x = this.animation.x;
            this.hitBox.y = this.animation.y;
          }
        }

        //безопасно двигаем, проверяя на столкновения    
        this.move = function(dx, dy){        
          var r1 = {x: this.animation.x - this.hitRadius, y: this.animation.y - this.hitRadius, w: 2*this.hitRadius, h: 2*this.hitRadius};
          var md = minDistance(r1);

          var dx0 = dx;
          var dy0 = dy;

          if(dx > 0) dx = (dx < md.right)? dx : md.right;
          else if(dx < 0) dx = (dx > - md.left)? dx : - md.left;

          if(dy > 0) dy = (dy < md.down)? dy : md.down;
          else if(dy < 0) dy = (dy > - md.up)? dy : - md.up;


          this.animation.x += dx;
          this.animation.y += dy;
          if(this.textAnimation != null){
            var tA = this.textAnimation;
            for(var i = 0; i < tA.length; i++)
              tA[i].move(dx, dy);
          }

          if(DEBUG){
            stage.removeChild(DEBUG_SHAPE);
            DEBUG_SHAPE = new createjs.Shape();
            DEBUG_SHAPE.graphics
                                .s("#ff0").mt(0,0).lt(0, - (md.up))
                                .s("#f00").mt(0,0).lt(0, (md.down))
                                .s("#f0f").mt(0,0).lt( - (md.left), 0)
                                .s("#0ff").mt(0,0).lt((md.right), 0)
                                .s("#0f0").mt(0,0).lt((dx + dx/Math.abs(dx)*this.hitRadius), (dy + dy/Math.abs(dy)*this.hitRadius));
            DEBUG_SHAPE.x = this.animation.x;
            DEBUG_SHAPE.y = this.animation.y;
            stage.addChild(DEBUG_SHAPE);  
          }
          // this.moveTo(this.animation.x + dx, this.animation.y + dy);          
        }

        this.rotate = function(alpha){
          this.animation.rotation = alpha;
        }

        this.loadJSON = function(data){
          var r = resources["zombieJSON"];
          r.images = [resources["zombie"]];

          this.hitRadius = r.hitRadius;
          this.maxHealthPoints = r.maxHealthPoints;
          this.healthPoints = r.maxHealthPoints;
          this.damage = r.damage;
          this.attackDelay = r.attackDelay;
          this.speed = r.speed;


          if(DEBUG){
            this.hitBox = new createjs.Shape();
            this.hitBox.graphics.s("#00f").r( - this.hitRadius, - this.hitRadius, 2*this.hitRadius, 2*this.hitRadius);
            this.hitBox.x = x;
            this.hitBox.y = y;
            stage.addChild(this.hitBox);
          }

          var ss = new createjs.SpriteSheet(r);             
          this.animation = new createjs.BitmapAnimation(ss);   
          this.animation.x = x;
          this.animation.y = y;
          this.animate("run");
          stage.addChild(this.animation);      
        }
        this.animate = function(arg){
          this.animation.gotoAndPlay(arg);    
        }
        this.hunt = function() {
          //Just follow to the player
          var a = Math.atan2(this.animation.y - player.animation.y, this.animation.x - player.animation.x) + Math.PI;

          this.animation.rotation = 180 * a / Math.PI + 90;

          var v = {x: 0, y: 0};
          v.x = this.speed * Math.cos(a); 
          v.y = this.speed * Math.sin(a);
          var x0 = this.animation.x;
          var y0 = this.animation.y;
          this.move(v.x, v.y);

          var r = {x1: this.animation.x - this.hitRadius, y1: this.animation.y - this.hitRadius,
                   x2: this.animation.x + this.hitRadius, y2: this.animation.y + this.hitRadius};

          var pr = {x1: player.animation.x - player.hitRadius, y1: player.animation.y - player.hitRadius,
                   x2: player.animation.x + player.hitRadius, y2: player.animation.y + player.hitRadius};

          var dist = {up:1, down:1, left:1, right:1}; //Все что угодно, кроме нуля
          getDistance(r, pr, dist);

          if(dist.up + dist.down + dist.left + dist.right < 4){//Касаемся игрока
            if(this.attackTicker <= 0){
              player.hit(this.damage);
              this.attackTicker = this.attackDelay;
            }
          }

          if(this.attackTicker > 0) this.attackTicker--;
        }

        //загружаем, отрисовываем зомбя
        this.loadJSON();

        //Запускаем слежение за игроком
        var ZZ = this;
        this.HH = createjs.Ticker.addEventListener("tick", function(evt){
          if(evt.paused) 
            return;
          ZZ.hunt();
        });
        
        this.imHit = function(id, dmg){

          this.healthPoints -= dmg;
          if(this.healthPoints <= 0){          
            stage.removeChild(this.hitBox);
            stage.removeChild(this.animation);
            var zomb = gMap.zombies;
            var HH = this.HH;
            createjs.Ticker.removeEventListener("tick", HH);          
            delete zomb.splice(id,1);
            stage.dispatchEvent("zombieKilled");
            return;
          }
          var t = new TextAnimation(this, "-" + dmg, "#e00");
        }
      }

      //Класс игрок
      function Player(x, y){
        x = x || 0;
        y = y || 0;
        this.speed = 3;
        this.weapon = null;
        this.healthPoints = 0;
        this.maxHealthPoints = 0;
        this.shootTicker = 0;

        this.animation = null;
        this.shotAnimation = null;
        this.textAnimation = [];

        this.hitRadius = 0;
        this.hitBox = null;
        this.healthBar = null;

        this.weapons = [];
        this.currentWeaponID = 0;


        //not safe teleport
        this.moveTo = function(x, y){        
          var x0 = this.animation.x;
          var y0 = this.animation.y;
          
          this.animation.x = x;
          this.animation.y = y;
          this.shotAnimation.x = x + 23*Math.cos(this.animation.rotation*Math.PI/180 - Math.PI/2 + 0.36);
          this.shotAnimation.y = y + 23*Math.sin(this.animation.rotation*Math.PI/180 - Math.PI/2 + 0.36);
          this.healthBar.x = x;
          this.healthBar.y = y;
          if(this.textAnimation != null){
            var dx = x - x0, dy = y - y0;
            var tA = this.textAnimation;
            for(var i = 0; i < tA.length; i++)
              tA[i].move(dx, dy);
          }

          if(DEBUG){
            this.hitBox.x = this.animation.x;
            this.hitBox.y = this.animation.y;
          }
        }

        //save move avoiding obstacles
        this.move = function(dx, dy){

          var r1 = {x: this.animation.x - this.hitRadius, y: this.animation.y - this.hitRadius, w: 2*this.hitRadius, h: 2*this.hitRadius};
          var md = minDistance(r1);

          if(dx > 0) dx = (dx < md.right)? dx : md.right;
          else if(dx < 0) dx = (dx > - md.left)? dx : - md.left;

          if(dy > 0) dy = (dy < md.down)? dy : md.down;
          else if(dy < 0) dy = (dy > - md.up)? dy : - md.up;

          this.animation.x += dx;
          this.animation.y += dy;
          this.shotAnimation.x = this.animation.x + 23*Math.cos(this.animation.rotation*Math.PI/180 - Math.PI/2 + 0.36);
          this.shotAnimation.y = this.animation.y + 23*Math.sin(this.animation.rotation*Math.PI/180 - Math.PI/2 + 0.36);
          this.healthBar.x += dx;
          this.healthBar.y += dy;
          if(this.textAnimation != null){
            var tA = this.textAnimation;
            for(var i = 0; i < tA.length; i++)
              tA[i].move(dx, dy);
          }

          if(DEBUG){
            stage.removeChild(DEBUG_SHAPE);
            DEBUG_SHAPE = new createjs.Shape();
            DEBUG_SHAPE.graphics
                                .s("#ff0").mt(0,0).lt(0, - (md.up))
                                .s("#f00").mt(0,0).lt(0, (md.down))
                                .s("#f0f").mt(0,0).lt( - (md.left), 0)
                                .s("#0ff").mt(0,0).lt((md.right), 0)
                                .s("#0f0").mt(0,0).lt((dx + dx/Math.abs(dx)*this.hitRadius), (dy + dy/Math.abs(dy)*this.hitRadius));
            DEBUG_SHAPE.x = this.animation.x;
            DEBUG_SHAPE.y = this.animation.y;
            stage.addChild(DEBUG_SHAPE);  
          }
        }

        this.loadJSON = function(data){
          function deepClone(arr){
            if(!(arr instanceof Array)) return null;
            var result = [];
            for(var i = 0; i < arr.length; i++){
              var w = {};
              for(var key in arr[i]){
                w[key] = arr[i][key];
              }
              result.push(w);
            }
            return result;
          }


          var r = resources["heroJSON"];
          r.images = [resources["hero"]];
          this.hitRadius = r.hitRadius;
          this.maxHealthPoints = r.maxHealthPoints;
          this.healthPoints = r.maxHealthPoints;

          this.shootTicker = 0;
          this.weapons = deepClone(r.weapons);
          console.log(r.weapons == this.weapons);

          this.healthBar = new createjs.Shape();
          this.healthBar.graphics.f("#f00").r( - this.maxHealthPoints/2, - this.hitRadius - 10, this.maxHealthPoints, 5);
          this.healthBar.x = x;
          this.healthBar.y = y;
          stage.addChild(this.healthBar);

          var rs = resources["shotJSON"];
          rs.images = [resources["shot"]];

          var sh = new createjs.SpriteSheet(rs);             
          this.shotAnimation = new createjs.BitmapAnimation(sh); 

          var ss = new createjs.SpriteSheet(r);             
          this.animation = new createjs.BitmapAnimation(ss); 
          this.animation.x = x;
          this.animation.y = y;
          this.animate("stay");


          if(DEBUG){
            this.hitBox = new createjs.Shape();
            this.hitBox.graphics.s("#00f").r( - this.hitRadius, - this.hitRadius, 2*this.hitRadius, 2*this.hitRadius);
            this.hitBox.x = x;
            this.hitBox.y = y;
            stage.addChild(this.hitBox);
          }

          stage.addChild(this.animation);
          stage.addChild(this.shotAnimation);
          createjs.Ticker.addEventListener("tick", this.handleTick);
          this.changeWeapon(0);
        }

        this.nextWeapon = function(){
          var n = (this.currentWeaponID + 1) % this.weapons.length;
          this.changeWeapon(n);
        }
        this.prevWeapon = function(){
          var n = (this.currentWeaponID - 1 + this.weapons.length) % this.weapons.length;
          this.changeWeapon(n);
        }
        this.changeWeapon = function(n){
          var w = this.weapons[n];
          this.currentWeaponID = n;
          this.weapon = w;
          var t = new TextAnimation(this, w.name, "#000");
        }

        this.animate = function(arg){
          this.animation.gotoAndPlay(arg);    
        }

        this.animateShot = function(arg){
          this.shotAnimation.gotoAndPlay(arg);    
        }
        this.shoot = function(x, y, angle){
          var recharge = this.weapon.shootDelay;
    
          if (this.shootTicker > 0)return false; 
          else this.shootTicker = recharge;

          var weapon = this.weapon;

          if(weapon.ammo == 0){
            var t = new TextAnimation(this, "Out of ammo", "#e00");
            return false;
          }

          //-1 == infinite ammo
          if(weapon.ammo != -1) {
            weapon.ammo--;
          }
          if(weapon.ammo != -1){
            var t = new TextAnimation(this, weapon.ammo, "#000", 200);
          }
          var scatter = weapon.scatter;
          angle += - scatter/2 + Math.random()*scatter;

          //(y1 – y2)x + (x2 – x1)y + (x1y2 – x2y1) = 0
          //var k = Math.tan(angle + Math.PI);
          /*var dx = x + 17*Math.cos(angle + 0.49);
          var dy = y + 17*Math.sin(angle + 0.49);*/
          var dx = x + 23*Math.cos(angle + 0.36);
          var dy = y + 23*Math.sin(angle + 0.36);
          var kA = dy - stage.mouseY;
          var kB = stage.mouseX - dx;
          var kC = dx*stage.mouseY - stage.mouseX*dy;      
          var shotVect = new Vec2(kB, -kA);
          var zCheck = new Vec2(0,0);
          var closestDist = 9000;
          var closestDistObst = 9000;
          var closestObst = 0; //id of closest obstacle
          var closestZ = 0; //id of closest Zombie
          var hitPoints = [];
          var shotPoints = [];
          for(var i = 0; i<2; i++){
            hitPoints[i] = {x:0, y:0};
            shotPoints[i] = {x:0, y:0};
          }
          function getDist(s,z){
            //var tempS = new Vec2(0,0);
            var cosAng = s.dot(z)/((s.length()*z.length()));
            if (cosAng < 0)return 9001;
            var sinAng = Math.sqrt(1-cosAng*cosAng);
            return sinAng*z.length();
          };
          
          function hitCheck(x, y, hitRadius){
            var x1 = x - hitRadius;
            var x2 = x + hitRadius;
            var y1 = y - hitRadius;
            var y2 = y + hitRadius;
            var i = 0;
            var y;
            var x;
            if (kB != 0){
              y = ((kA*x1+kC)/(-kB));
              if (y <= y2 && y >=y1){
                hitPoints[i].x = x1;
                hitPoints[i].y = y;
                i++;
              }
              y = ((kA*x2+kC)/(-kB));
              if (y <= y2 && y >=y1){
                hitPoints[i].x = x2;
                hitPoints[i].y = y;
                i++;
              }
            }else{
              if (dx <= x2 && dx >= x1){
                for(i = 0; i<2; i++)hitPoints[i].x = dx
                  hitPoints[0].y = y1;
                  hitPoints[1].y = y2;
              }
            }
            if (kA != 0 && i < 2){
              x = ((kB*y1+kC)/(-kA));
              if (x <= x2 && x >=x1){
                hitPoints[i].x = x;
                hitPoints[i].y = y1;
                i++;
              }
              if (i < 2){
                x = ((kB*y2+kC)/(-kA));            
                if (x <= x2 && x >=x1){
                  hitPoints[i].x = x;
                  hitPoints[i].y = y2;
                  i++;
                }
              }
            }else{
              if (i == 0 && dx <= x2 && dx >= x1){
                for(i = 0; i<2; i++)hitPoints[i].y = dy
                  hitPoints[0].x = x1;
                  hitPoints[1].x = x2;
              }
            }
            if (i == 2){
              var v1 = new Vec2(hitPoints[0].x - dx, hitPoints[0].y - dy);
              var v2 = new Vec2(hitPoints[1].x - dx, hitPoints[1].y - dy);
              if (v1.length()>v2.length()){
                var temp = hitPoints[0];
                hitPoints[0] = hitPoints[1];
                hitPoints[1] = temp;
              }
              return true;
            } else return false;
          }
          //ищем того самого, единственного зомби, который будет повержен... ах...
          for (var i = 0; i < gMap.zombies.length; i++){
            zCheck.x = gMap.zombies[i].animation.x - dx;
            zCheck.y = gMap.zombies[i].animation.y - dy;
            if (getDist(shotVect, zCheck)<16 && hitCheck(gMap.zombies[i].animation.x, gMap.zombies[i].animation.y,
                                                         gMap.zombies[i].hitRadius))
            {
              gMap.zombies[i].hitPoints[0].x = hitPoints[0].x;
              gMap.zombies[i].hitPoints[0].y = hitPoints[0].y;
              gMap.zombies[i].hitPoints[1].x = hitPoints[1].x;
              gMap.zombies[i].hitPoints[1].y = hitPoints[1].y;
              if (zCheck.length() < closestDist){
                //zCheck = zCheck.abs();
                closestDist = zCheck.length();
                closestZ = i;
              }
            }
          }
          //стены стены!
          for (var i = 0; i < gMap.obstacles.length; i++){
            zCheck.x = gMap.obstacles[i].x - dx + gMap.obstacles[i].width/2;
            zCheck.y = gMap.obstacles[i].y - dy + gMap.obstacles[i].height/2;
            if (getDist(shotVect, zCheck)<20 && hitCheck(gMap.obstacles[i].x+gMap.obstacles[i].width/2,
                                                         gMap.obstacles[i].y+gMap.obstacles[i].height/2,
                                                         /*gMap.obstacles[i].hitRadius*/22)) //ааа говнокод, нужна переменная!!!
            {
              gMap.obstacles[i].hitPoints[0].x = hitPoints[0].x;
              gMap.obstacles[i].hitPoints[0].y = hitPoints[0].y;
              gMap.obstacles[i].hitPoints[1].x = hitPoints[1].x;
              gMap.obstacles[i].hitPoints[1].y = hitPoints[1].y;
              if (zCheck.length() < closestDistObst){
                //zCheck = zCheck.abs();
                closestDistObst = zCheck.length();
                closestObst = i;
              }
            }
          }
          if (closestDistObst > closestDist){
            var dmgDealt = player.weapon.damage + Math.round( - player.weapon.damageDelta /2 + Math.random()*player.weapon.damageDelta);
            gMap.zombies[closestZ].imHit(closestZ, dmgDealt);
            createjs.Sound.play("hitIt", "none", 100);
          }else{
            hitPoints[0].x = gMap.obstacles[closestObst].hitPoints[0].x;
            hitPoints[0].y = gMap.obstacles[closestObst].hitPoints[0].y;
            hitPoints[1].x = gMap.obstacles[closestObst].hitPoints[1].x;
            hitPoints[1].y = gMap.obstacles[closestObst].hitPoints[1].y;        
          }
          if(DEBUG){
            var g = new createjs.Shape();
                g.graphics.setStrokeStyle(1);
                g.graphics.beginStroke("#FF0000");
                g.graphics.beginFill("#0000FF");
                g.graphics.drawCircle(hitPoints[0].x,hitPoints[0].y,3);
                g.graphics.beginFill("#FF0000");
                g.graphics.drawCircle(hitPoints[1].x,hitPoints[1].y,3);
                g.x = 0;
                g.y = 0;
            stage.addChild(g); 
          }
          //не убирай коменты - вдруг еще пригодится=)
          //как минимум здесь расчет правильного угла для стрельбы...
          
          var length = 50 + 2 * Math.random() * weapon.damage;
          var s = new createjs.Shape();
          var da = Math.atan2(stage.mouseY - dy, stage.mouseX - dx);
          var dr = 5 + Math.random()*10;
          s.graphics.s("#808080").mt(dx /*+ (10+dr)*Math.cos(da)*/, dy /*+ (10+dr)*Math.sin(da)*/);
          //s.graphics.s("#F0E68C").mt(dx, dy);
          s.graphics.lt(x + length*Math.cos(angle), y + length*Math.sin(angle));
          stage.addChild(s);
          var t = 0;
          var tr = 0;
          //я знаю, что здесь МОЖНО сделать лучше, но не знаю как
          createjs.Ticker.addEventListener("tick", function(evt){
            if(evt.paused)return;
            if (t > 3){
              t = 0;
              stage.removeChild(s);
            }else t++;          
          });//
          switch (weapon.name){
            case "gun" : createjs.Sound.play("pistolShot"); break;
            case "machine" : createjs.Sound.play("uziShot"); break;
            case "rifle" : createjs.Sound.play("rifleShot"); createjs.Sound.play("rifleRecharge", "none", weapon.shootDelay*1000/60 - 800); break;
          }
          return true;
        }

        //Ударить игрока
        this.hit = function(dmg){    
          if(this.healthPoints <= 0) return;      
          this.healthPoints -= dmg;
          if(this.healthPoints > this.maxHealthPoints) this.healthPoints = this.maxHealthPoints;
          var color;
          if(dmg >= 0) {
            var t = new TextAnimation(this, "-" + dmg, "#e00");
              createjs.Sound.play("zBite");
            }
          else var t = new TextAnimation(this, "+" + (-dmg), "#0c0");

          

          this.healthBar.graphics.c().s(0).f("#f00").r( - this.maxHealthPoints/2, - this.hitRadius - 10,
                                                    this.healthPoints, 5)
                                 .s("#f00").f(0).r( - this.maxHealthPoints/2, - this.hitRadius - 10,
                                                    this.maxHealthPoints, 5);
          if(this.healthPoints <= 0){//умереть            
            stage.dispatchEvent("playerDied");
          }
        }
        
        this.handleTick = function(evt) {
          if(evt.paused)return;
          //Просто смотрим на мышку

          var a = Math.atan2(stage.mouseY - player.animation.y, stage.mouseX - player.animation.x) + Math.PI / 2;
          player.animation.rotation = 180 * a / Math.PI;

          player.shotAnimation.rotation = player.animation.rotation;
          player.shotAnimation.x = player.animation.x + 23*Math.cos(a - Math.PI/2 + 0.35);
          player.shotAnimation.y = player.animation.y + 23*Math.sin(a - Math.PI/2 + 0.35);

          var v = {x:0, y:0};  // player speed vector

          if(lfHeld) v.x = - player.speed;
          if(rtHeld) v.x = player.speed;
          if(fwdHeld) v.y = - player.speed;
          if(bwdHeld) v.y = player.speed;

          if(shootHeld) {
            if (player.shoot(player.animation.x, player.animation.y, a - Math.PI/2)){
              player.animateShot("s0");
            }
          }

          if(player.shootTicker > 0) player.shootTicker--;

          if(v.x * v.x + v.y * v.y == 0){
            player.animate("stay");
          }else{
            if(player.animation.currentAnimation != "run")
              player.animate("run");
          }    

          var x0 = player.animation.x, y0 = player.animation.y;

          player.move(v.x, v.y);

          var x1 = player.animation.x, y1 = player.animation.y;          

          var mapMove = {dx:0, dy:0};
          var mvC = 0.4; // Константа, поределяющая перемещение карты

          if(x1 < WIDTH * mvC  && (x0 - x1) > 0)
            mapMove.dx = x0 - x1;
          if(y1 < HEIGHT * mvC && (y0 - y1) > 0)
            mapMove.dy = y0 - y1;

          if(x1 > WIDTH * (1 - mvC) && (x0 - x1) < 0)
            mapMove.dx = x0 - x1;
          if(y1 > HEIGHT * (1 - mvC) && (y0 - y1) < 0)
            mapMove.dy = y0 - y1;

          if(Math.abs(mapMove.dx) + Math.abs(mapMove.dy) > 0){
            gMap.move(mapMove.dx, mapMove.dy);
          }
          
        }        
        this.loadJSON();
      }

    
      function Bonus(type, data){
        this.type = null;
        this.animation = null;
        this.width = 0;
        this.height = 0;
        this.value = 0;

        this.load = function(type, data){
          this.type = type;
          var bData = resources["bonusJSON"][type];//bonus parameters

          var b = new createjs.Bitmap(resources["bonus"]);
          b.sourceRect = new createjs.Rectangle(bData.x, bData.y, bData.width, bData.height);
          b.regX = bData.width/2;
          b.regY = bData.height/2;
          b.x = data.x;
          b.y = data.y;
          this.width = bData.width;
          this.height = bData.height;
          this.value = bData.value;
          this.animation = b;
          stage.addChild(b);

          gMap.bonuses.push(this);          
        }
        this.touchCheck = function(event){
          var r = {x1: this.animation.x - this.width/2, y1: this.animation.y - this.height/2,
                   x2: this.animation.x + this.width/2, y2: this.animation.y + this.height/2};

          var pr = {x1: player.animation.x - player.hitRadius, y1: player.animation.y - player.hitRadius,
                   x2: player.animation.x + player.hitRadius, y2: player.animation.y + player.hitRadius};

          var dist = {up:1, down:1, left:1, right:1}; //Все что угодно, кроме нуля
          getDistance(r, pr, dist);

          if(dist.up + dist.down + dist.left + dist.right < 4){//Касаемся игрока
            if(this.type == "medkit"){
              //Нанесем отрицательный урон, то же, что и вылечить
              player.hit(- this.value);
            }
            if(this.type == "ammo"){
              //50 патронов для автомата и 10 для снайперки, пистолет с бесконечными
              player.weapons[1].ammo += 50;
              player.weapons[2].ammo += 10;
              var t = TextAnimation(player, "Ammo", "#0e0");
            }   
            //Удаляем себя, бонус использован
            stage.removeChild(this.animation);
            var bs = gMap.bonuses;
            for(var i = 0; i < bs.length; i++)
              if(bs[i] == this) break;

            var tH = this.tickHandler;
            createjs.Ticker.removeEventListener("tick", tH);
            delete bs.splice(i,1);
          }          

        }

        this.load(type, data);
        var self = this;
        this.tickHandler = createjs.Ticker.addEventListener("tick", function(evt){
          if(evt.paused) return;
          self.touchCheck();
        });
      }

      //Класс зомби спаунера
      //Передаем туда структуру с информацией о позиции, времени первого спауна, количестве спанов      
      function ZombieSpawner(data){
        this.spawnDelay = data.properties.delay;
        this.startTimeMs = data.properties.startTimeMs;
        this.spawnNumber = data.properties.number;

        this.nextSpawnTime = this.startTimeMs;

        this.x = data.x;
        this.y = data.y;

        this.spawnHandler = function(event){
          if(event.paused)return;
          SZ.nextSpawnTime  -= event.delta;

          if(SZ.spawnNumber > 0 && SZ.nextSpawnTime <= 0){
            var z = new Zombie(SZ.x, SZ.y); 
            gMap.zombies.push(z);
            SZ.spawnNumber--;
            SZ.nextSpawnTime = SZ.spawnDelay;            
          }else{
            if(SZ.spawnNumber === 0){
              createjs.Ticker.removeEventListener("tick", SZ.tickListener);
            }
          }
        }

        var SZ = this;
        this.tickListener = createjs.Ticker.addEventListener("tick", function(evt){SZ.spawnHandler(evt);});
      }

      function startMenu(){
        //gMap = new TILEDMap();

        var menu = ["Large Map", "Test map 4", "Test map 5"];
        var menuMaps = ["omgLargeMap", "testMap4", "testMap5"];
        for(var i = 0; i < menu.length; i++){
          var btn = document.createElement("input");
          btn.type = "button";
          btn.value = menu[i];
          btn.mapName = menuMaps[i];
          btn.onclick = function(){ gMap.load(this.mapName);};
          body.appendChild(btn);
        }
        var pauseBtn = document.createElement("input");
        pauseBtn.type = "button";
        pauseBtn.value = "Pause";
        pauseBtn.onclick = function(){ createjs.Ticker.setPaused(true);};
        body.appendChild(pauseBtn);
        var playBtn = document.createElement("input");
        playBtn.type = "button";
        playBtn.value = "Play";
        playBtn.onclick = function(){ createjs.Ticker.setPaused(false);};
        body.appendChild(playBtn);
      }

      //Загрузка всех ресурсов, и запуск функции init()
      function load(){
        var preLoads;

        var objQueue = new createjs.LoadQueue();
        objQueue.installPlugin(createjs.Sound);
        //loadScreen add
        init();
              
        var tempBar = new loadBar();
        tempBar.drawBackBar(WIDTH/4, HEIGHT/2, WIDTH/2, 20)

        var currParts = 0;
        objQueue.addEventListener("fileload", function(){
        currParts++;
        tempBar.drawBar(WIDTH/4, HEIGHT/2, (WIDTH/2)*currParts/LOAD_PARTS, 20, Math.floor(100*currParts/LOAD_PARTS));          
         //console.log(currParts);
        })
          
        //end loadScreen
        objQueue.addEventListener("complete", function(){             
            for (var i = 0; i < preLoads.length; i++){ //loading all files from 'preLoads'
              resources[preLoads[i].name] = objQueue.getResult(preLoads[i].name);
            }
            CLMenu(WIDTH/2.5, HEIGHT/1.5, WIDTH/4, 50, tempBar); // CompleteLoadMenu
        });        
        xhrGet("data\\preLoads.json", 
                this, 
                function(data){
                  preLoads = JSON.parse(data.responseText);
                  for (var i = 0; i < preLoads.length; i++){ //loading all files from 'preLoads.json'
                    objQueue.loadFile({id:preLoads[i].name, src:preLoads[i].src});
                  };
                }
        ); //we load all src links into 'preLoads'

      }
      
      //Создаем канвас, грузим карту, игрока, зомбей, запускаем
      function init() {

        var canvas = document.createElement("canvas");
        canvas.width = WIDTH;
        canvas.height = HEIGHT;
        canvas.id = "gameCanvas";
        body.appendChild(canvas);

        stage = new createjs.Stage("gameCanvas");
        createjs.Ticker.setFPS(60);
        createjs.Ticker.addEventListener("tick", function(evt){
          stage.update();
        });
        stage.addEventListener("stagemousedown", function(){
          shootHeld = true;
        });
        stage.addEventListener("stagemouseup", function(){
          shootHeld = false;
        });

        //startMenu();
      }
      

      function handleKeyDown(e) {
        //cross browser issues exist
        if(!e){ var e = window.event; }
        switch(e.keyCode) {
          case KEYCODE_SPACE: shootHeld = true; return false;
          case KEYCODE_A:
          case KEYCODE_LEFT:  lfHeld = true; return false;
          case KEYCODE_D:
          case KEYCODE_RIGHT: rtHeld = true; return false;
          case KEYCODE_W:
          case KEYCODE_UP:  fwdHeld = true; return false;
          case KEYCODE_S:
          case KEYCODE_DOWN:  bwdHeld = true; return false;
          case KEYCODE_ESC:
          case KEYCODE_P:  pause = new gamePause(); return false;
          case KEYCODE_Q: player.prevWeapon(); return false;
          case KEYCODE_E: player.nextWeapon(); return false;

          case KEYCODE_1: player.changeWeapon(0); return false;
          case KEYCODE_2: player.changeWeapon(1); return false;
          case KEYCODE_3: player.changeWeapon(2); return false;

          case KEYCODE_M: if(!muted){
                            createjs.Sound.setVolume(0);
                          }else{
                            createjs.Sound.setVolume(1);
                          }; muted =! muted;

        }
      }

      function handleKeyUp(e) {
        //cross browser issues exist
        if(!e){ var e = window.event; }
        switch(e.keyCode) {
          case KEYCODE_SPACE: shootHeld = false; break;
          case KEYCODE_A:
          case KEYCODE_LEFT:  lfHeld = false; break;
          case KEYCODE_D:
          case KEYCODE_RIGHT: rtHeld = false; break;
          case KEYCODE_W:
          case KEYCODE_UP:  fwdHeld = false; break;
          case KEYCODE_S:
          case KEYCODE_DOWN:  bwdHeld = false; break;       
          case KEYCODE_ESC:
          case KEYCODE_P:  pauseHeld = false; break;          
        }
      }

      //Класс многослойной карты из тайлов
      var TILEDMap = function(){
          // This is where we store the full parsed
          // JSON of the map.json file.
          this.currMapData = null;

          //Array of obstacle rectangles
          this.obstacles = [];

          //Zombie spawn object
          this.zombSpawners = [];

          //Zombies
          this.zombies = [];
          this.playerSpawn = null;

          //Array of bonus objects
          this.bonuses = [];          

          // tilesets stores each individual tileset
          // from the map.json's 'tilesets' Array.
          // The structure of each entry of this
          // Array is explained below in the
          // parseAtlasDefinition method.
          this.tilesets = [];

          //creaeteJS bitmaps array
          this.tiles = [];

          // This is where we store the width and
          // height of the map in tiles. This is
          // in the 'width' and 'height' fields
          // of map.json, respectively.
          // The values 100 here are just set
          // so these fields are initialized to
          // something, rather than null.
          this.numXTiles = 100;
          this.numYTiles = 100;

          // The size of each individual map
          // tile, in pixels. This is in the
          // 'tilewidth' and 'tileheight' fields
          // of map.json, respectively.
          // The values 64 here are just set
          // so these fields are initialized to
          // something, rather than null.
          this.tileSize = {
              "x": 64,
              "y": 64
          };

          // The size of the entire map,
          // in pixels. This is calculated
          // based on the 'numXTiles', 'numYTiles',
          // and 'tileSize' parameters.
          // The values 64 here are just set
          // so these fields are initialized to
          // something, rather than null.
          this.pixelSize = {
              "x": 64,
              "y": 64
          };

          this.position = {x: 0, y: 0, w:0, h:0};
          this.reset = function(){
              //Clear all resources              
              createjs.Ticker.removeAllEventListeners("tick");
              stage.removeAllEventListeners("zombieKilled");
              stage.removeAllEventListeners("playerDied");
              stage.removeAllChildren();
              this.currMapData = null;
              this.obstacles = [];
              this.zombSpawners = [];
              this.zombies = [];
              this.playerSpawn = null;
              this.tilesets = [];
              this.tiles = [];   
              createjs.Ticker.addEventListener("tick", function(evt){
                if(evt.paused)return;
                stage.update();
              });
              lfHeld = rtHeld = fwdHeld = bwdHeld = shootHeld = pauseHeld = false;
          }

          this.load = function (mapName) {      
              this.reset();
              createjs.Ticker.setPaused(false);

              stage.addEventListener("zombieKilled", function(){
                var n = gMap.zombies.length - 1;//Количество зомбей
                var zS = gMap.zombSpawners;
                for(var i = 0, l = zS.length; i < l && n === 0; i++)
                  n += zS[i].spawnNumber;
                if(n === 0){
                  gMap.reset();
                  alert("You won!");
                  changeMusic("mainTheme", 21500, -1);
                  var d = new drawMenu(true);
                }
              });

              stage.addEventListener("playerDied", function(){
                  gMap.reset();
                  alert("You lost!");
                  changeMusic("mainTheme", 21500, -1);
                  var d = new drawMenu(true);
              });              

              this.currMapData = resources[mapName];

              var map = this.currMapData;
            
              // Set 'numXTiles' and 'numYTiles' from the
              // 'width' and 'height' fields of our parsed
              // map data.
              this.numXTiles = map.width;
              this.numYTiles = map.height;
            
              // Set the 'tileSize.x' and 'tileSize.y' fields
              // from the 'tilewidth' and 'tileheight' fields
              // of our parsed map data.
              this.tileSize.x = map.tilewidth;
              this.tileSize.y = map.tileheight;
            
              // Set the 'pixelSize.x' and 'pixelSize.y' fields
              // by multiplying the number of tiles in our map
              // by the size of each tile in pixels.
              this.pixelSize.x = this.numXTiles * this.tileSize.x;
              this.pixelSize.y = this.numYTiles * this.tileSize.y;

              // Loop through 'map.tilesets', an Array...              
              for(var i = 0; i < map.tilesets.length; i++) {
                  //Load image from resources
                  var img = resources[map.tilesets[i].name];

                  // This is the javascript object we'll create for
                  // the 'tilesets' Array above. First, fill in the
                  // given fields with the corresponding fields from
                  // the 'tilesets' Array in 'currMapData'.
                  var ts = {
                      "firstgid": map.tilesets[i].firstgid,

                      // 'image' should equal the Image object we
                      // just created.

                      "image": img,
                      "imageheight": map.tilesets[i].imageheight,
                      "imagewidth": map.tilesets[i].imagewidth,
                      "name": map.tilesets[i].name,

                      // These next two fields are tricky. You'll
                      // need to calculate this data from the
                      // width and height of the overall image and
                      // the size of each individual tile.
                      // 
                      // Remember: This should be an integer, so you
                      // might need to do a bit of manipulation after
                      // you calculate it.

                      "numXTiles": Math.floor(map.tilesets[i].imagewidth / this.tileSize.x),
                      "numYTiles": Math.floor(map.tilesets[i].imageheight / this.tileSize.y)
                  };

                  // After that, push the newly created object into
                  // the 'tilesets' Array above. Javascript Arrays
                  // have a handy method called, appropriately, 'push'
                  // that does exactly this. It takes the object
                  // we'd like to put into the Array as a parameter.
                  // 
                  // YOUR CODE HERE
                  this.tilesets.push(ts);
              }
              this.draw();
          };

          //-----------------------------------------
          // Grabs a tile from our 'layer' data and returns
          // the 'pkt' object for the layer we want to draw.
          // It takes as a parameter 'tileIndex', which is
          // the id of the tile we'd like to draw in our
          // layer data.
          this.getTilePacket = function (tileIndex) {

              // We define a 'pkt' object that will contain
              // 
              // 1) The Image object of the given tile.
              // 2) The (x,y) values that we want to draw
              //    the tile to in map coordinates.
              var pkt = {
                  "img": null,
                  "px": 0,
                  "py": 0
              };

              // The first thing we need to do is find the
              // appropriate tileset that we want to draw
              // from.
              //
              // Remember, if the tileset's 'firstgid'
              // parameter is less than the 'tileIndex'
              // of the tile we want to draw, then we know
              // that tile is not in the given tileset and
              // we can skip to the next one.
              var tile = 0;

              for(tile = this.tilesets.length - 1; tile >= 0; tile--) {
                  if(this.tilesets[tile].firstgid <= tileIndex) break;
              }

              // Next, we need to set the 'img' parameter
              // in our 'pkt' object to the Image object
              // of the appropriate 'tileset' that we found
              // above.
              pkt.img = this.tilesets[tile].image;


              // Finally, we need to calculate the position to
              // draw to based on:
              //
              // 1) The local id of the tile, calculated from the
              //    'tileIndex' of the tile we want to draw and
              //    the 'firstgid' of the tileset we found earlier.
              var localIdx = tileIndex - this.tilesets[tile].firstgid;

              // 2) The (x,y) position of the tile in terms of the
              //    number of tiles in our tileset. This is based on
              //    the 'numXTiles' of the given tileset. Note that
              //    'numYTiles' isn't actually needed here. Think about
              //    how the tiles are arranged if you don't see this,
              //    It's a little tricky. You might want to use the 
              //    modulo and division operators here.
              var lTileX = Math.floor(localIdx % this.tilesets[tile].numXTiles);
              var lTileY = Math.floor(localIdx / this.tilesets[tile].numXTiles);

              // 3) the (x,y) pixel position in our tileset image of the
              //    tile we want to draw. This is based on the tile
              //    position we just calculated and the (x,y) size of
              //    each tile in pixels.
              pkt.px = (lTileX * this.tileSize.x);
              pkt.py = (lTileY * this.tileSize.y);


              return pkt;
          };

          //-----------------------------------------
          // Draws all of the map data
          this.draw = function () {

              var x0 = WIDTH, y0 = HEIGHT;//left top corner
              var x1 = 0, y1 = 0;//right bottom corner
              // For every single layer in the 'layers' Array
              // of 'currMapData'...
              for(var layerIdx = 0; layerIdx < this.currMapData.layers.length; layerIdx++) {
                  //Если слой тайлов, то рисуем, если слой объектов - расставляем на карте
                  if(this.currMapData.layers[layerIdx].type == "tilelayer"){                
                    // ...Grab the 'data' Array of the given layer...
                    var dat = this.currMapData.layers[layerIdx].data;

                    var layerName = this.currMapData.layers[layerIdx].name;

                    // ...For each tileID in the 'data' Array...
                    for(var tileIDX = 0; tileIDX < dat.length; tileIDX++) {

                        // ...Check if that tileID is 0. Remember, we don't draw
                        // draw those, so we can skip processing them...
                        var tID = dat[tileIDX];
                        if(tID === 0) continue;                      
                        // ...If the tileID is not 0, then we grab the
                        // packet data using getTilePacket.
                        var tPKT = this.getTilePacket(tID);

                        // Now we need to calculate the (x,y) position we want to draw
                        // to in our game world.
                        //
                        // We've performed a similar calculation in 'getTilePacket',
                        // think about how to calculate this based on the tile id and
                        // various tile properties that our TILEDMapClass has.

                        var dx = Math.floor(tileIDX % this.numXTiles) * this.tileSize.x;
                        var dy = Math.floor(tileIDX / this.numXTiles) * this.tileSize.y;



                        // avoid drawing obstacle tiles
                        if(layerName != "obstacles"){
                          // Now, we're finally drawing the map to our canvas!

                          var b = new createjs.Bitmap(tPKT.img);
                          b.sourceRect = new createjs.Rectangle(tPKT.px, tPKT.py, this.tileSize.x, this.tileSize.y);

                          
                          //Find top-left corner position
                          if(dx < x0) x0 = dx;
                          if(dy < y0) y0 = dy;

                          //Find right-bottom corner position
                          if(dx + this.tileSize.x > x1) x1 = dx + this.tileSize.x;
                          if(dy + this.tileSize.y > y1) y1 = dy + this.tileSize.y;

                          b.x = dx;
                          b.y = dy;
                          stage.addChild(b);  
                          this.tiles.push(b); 
                        }else{ 
                          // Add obstacle to array
                          
                          var r = new createjs.Rectangle(dx, dy, this.tileSize.x, this.tileSize.y);   
                          var hitPoints = [];
                          for(var i = 0; i<2; i++)hitPoints[i] = {x:0, y:0};
                          r["hitPoints"] = hitPoints;
                          this.obstacles.push(r);

                          if(DEBUG){
                            var ddd = new createjs.Shape();
                            ddd.graphics.s("#f00").r(r.x, r.y, r.width, r.height);                          
                            stage.addChild(ddd);
                          }
                        }
                    }
                  }
                  if(this.currMapData.layers[layerIdx].type == "objectgroup"){ 
                    var data = this.currMapData.layers[layerIdx].objects;

                    for (var i = data.length - 1; i >= 0; i--) {

                      if(data[i].type == "zombSpawn"){
                        var spawner = new ZombieSpawner(data[i]);
                        this.zombSpawners.push(spawner);
                        continue;
                      }

                      if(data[i].type == "playerSpawn"){ 
                        player = new Player(data[i].x, data[i].y); 
                        console.log(player);
                        this.zombies.push(player);//Добавим игрока в массив зомбей, чтобы легко проверять на столкновения
                        continue;
                      }


                      // //Not zombie, not 
                      // var bData = resources["bonusJSON"][data[i].type];//bonus parameters
                      
                      // var b = new createjs.Bitmap(resources["bonus"]);
                      // b.sourceRect = new createjs.Rectangle(bData.x, bData.y, bData.width, bData.height);
                      // b.x = data[i].x - bData.width/2;
                      // b.y = data[i].y - bData.height/2;
                      // this.tiles.push(b);
                      // stage.addChild(b);

                      var b = new Bonus(data[i].type, data[i]);
                    };
                  }
              }

            var x = player.animation.x; 
            var y = player.animation.y;
            this.position.x = x0;
            this.position.y = y0;
            this.position.w = x1 - x0;
            this.position.h = y1 - y0;
            gMap.move(- x + WIDTH/2, - y + HEIGHT/2);//Центрируем карту
          }



          //Подвинем все тайлы, всех зомбей, все спаунеры зомбей

          this.move = function (dx, dy){
            dx = dx || 0;
            dy = dy || 0;

            var i = 0;
            var dx1 = this.position.x;
            if(dx > 0){
              if(dx + this.position.x > 0) dx = - this.position.x;
            }else if(dx < 0){
              if(dx + this.position.x + this.position.w < WIDTH) 
                dx = (dx > WIDTH - (this.position.x + this.position.w))? dx : WIDTH - (this.position.x + this.position.w);
            }

            if(dy > 0){
              if(dy + this.position.y > 0) dy = - this.position.y;
            } else 
              if(dy < 0){
                if(dy + this.position.y + this.position.h < HEIGHT) 
                  dy = (dy > HEIGHT - (this.position.y + this.position.h))? dy : HEIGHT - (this.position.y + this.position.h);
              }

            var tilesArr = this.tiles;
            for (i = tilesArr.length - 1; i >= 0; i--) {
              tilesArr[i].x += dx;
              tilesArr[i].y += dy;
            };

            var obstArr = this.obstacles;
            for (i = obstArr.length - 1; i >= 0; i--) {
              obstArr[i].x += dx;
              obstArr[i].y += dy;
            };


            for (i = this.zombies.length - 1; i >= 0; i--) {
              var z = this.zombies[i];
              z.moveTo(z.animation.x + dx,z.animation.y + dy);
            };

            var zSpawn = this.zombSpawners;
            for (i = zSpawn.length - 1; i >= 0; i--) {
              zSpawn[i].x += dx;
              zSpawn[i].y += dy;
            };
            
            var bonuses = this.bonuses;
            for (i = bonuses.length - 1; i >= 0; i--) {
              bonuses[i].animation.x += dx;
              bonuses[i].animation.y += dy;
            };            


            this.position.x +=dx;
            this.position.y +=dy;
          }
      };
    </script>  

    <div id="instructions">
      <h3>Instructions</h3>
      You are alone in this city. Masses of zombies are coming! Kill'em all, or die!<br>
      Don't stay, collect bonuses and shot!
      Enjoy!


      <h3>Hot keys:</h3>      
      <ul>
        <li> WASD to move</li>
        <br />
        <li> 1 - pistol</li>
        <li> 2 - machine gun</li>
        <li> 3 - sniper riffle </li>
        <br />
        <li> Q - previous weapon</li>
        <li> E - next weapon</li>
        <br />
        <li> M - mute </li>
        <li> Esc, P - pause </li>
      </ul>


      <h3>Autors:</h3>
        <b>Code:</b> Andrey Kokorev, Paul Chursin <br>
        <b>Background music:</b> Paul Chursin <br>
        <b>Animation and art:</b> Andrey Kokorev<br>
        There are a github repository for this game: <a href="https://github.com/Andronnix/mustached-ninja">https://github.com/Andronnix/mustached-ninja</a>
        <br>
        You can find us here on github: <a href="https://github.com/blOOdmOnstEr"> Chursin Pavel (blOOdmOnstEr)</a>, <a href="https://github.com/Andronnix"> Andrey Kokorev (Andronnix)</a> 
    </div>

  </BODY>
</HTML>
